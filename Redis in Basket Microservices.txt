Redis in Basket Microservices
Redis In Basket Microservices
- Implement Proxy pattern, decorator Pattern
- Implement Cache-aside Pattern/ Cache invalidation
- Develop Cached BasketRepository and Decorate Scrutor Library
- Setup Redis as a Distributed Cache using Docker-compose
- Integrate Redis into out Basket Microservices to cache user cart data

Cache-Aside Pattern for Microservices

What is Proxy and Decorator patterns?
Proxy Pattern
- Tạo ra 1 lớp mới đại diện cho lớp service đang có cùng 1 interface, lớp này gọi là proxy
- Giống như 1 người bảo vệ có thể thêm các hành vi hoặc kiểm tra bổ sung trước khi truy cập vào đối tượng thực tế
Decorator patterns
- Là một mẫu thiết kế cấu trúc cho phép bạn đính kèm các hành vi mới vào đối tượng bằng cách đặt đối tượng này bên trong các đối tượng khác bao bọc đặc biệt có chứa các hành vi đó dựa vào inject 
- đối mới decorator thì mở rộng chức năng repository bằng cách thêm logic lưu trữ cache


Ở đây theo Proxy Pattern: thì CachedBasketRepository là là Proxy và chuyển tiếp các cuộc gọi đến kho lưu trữ giỏ hàng

Sử dụng cache để giảm tần suất truy cập cơ sở dữ liệu
Thêm triển khai logic lưu trữ đệm trọng mỗi phương thức và giảm số lần gọi cơ sở dữ liệu
.NET đã cung cấp phương thức để lưu Cached

Microservices Synchoronous Communication
- Giao tiếp đồng bộ sử dụng giao thức HTTP hoặc gRPC  để trả về response
- Máy khách sẽ chặn luồng của họ cho đến khi nhận được phản hồi từ server
- Giao thức truyền thông đồng bộ có thể dử dụng là http hoặc https
- Máy khách sẽ call the server và block các chức năng cho tới khi nhận được phản hồi từ server
Microservies Asynchonous Commuication
- Về cơ bản là máy khách gửi request nhưng không cần chờ phản hồi
- Máy khách ko nên chặn 1 luồng trong khi chờ phản hồi
- Giao thức thường dùng là: AMQP (advance message queuing protocol): Kafka, RabbitMQ 

Sử dụng 4 giao thức: 
- Rest http APIs để gửi request từ microservices
- gRPC APIs để giao tiếp bên trong microservecies
- GraphQL APIs khi dữ liệu linh hoạt có cấu trúc trong các dịch vụ siêu nhỏ 
- Web socket: Khi giao tiếp 2 chiều thời gian thực

gRPC: là Remote Procedure call. Sử dụng hiệu quả kết nối trong hệ thống phân tán. Hiệu quả cá dùng HTTP/2 protocol để truyền tải tin nhắn nhị phân.

How gRPC work: dùng để giao tiếp giữa backend to backend => CPU không gánh nhiều cost cho encode/decodeing nữa.

Protocol Buffers là một công cụ định nghĩa cấu trúc dữ liệu và giao thức truyền thông giữa các ứng dụng
Để định nghĩa giao diện dịch vụ với Protocol Buffers trogn gRPC cần thực hiện các bước sau:
- Định nghĩa file .proto: mô tả cấu trúc dữ liệu và giao diện dịch vụ - Định nghĩa message và service 
- Biên dịch file .proto: sử dụng biên dịch protocal buffer để tạo các class hoặc interface cho ngôn ngữ lập trình mục tiêu
- Triên khai logic dịch vụ: sử dụng các class hoặc interface được tạo ra để triển khai logic xử lý dịch vụ và truyền thông giữa client và server gRPC.

Cơ chế hoạt động: 
là cơ chế cho phép client gọi các phương thức từ xa trên server một cách tương tự như việc gọi các hàm cục bộ
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
DDD:

Domain event:
Gửi các sự kiện đến các application khác khi có sự thay đổi trong Domain

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

CQRS - Command Query Responsibility Segragation

- CQRS design pattern in order to avoid complex queries to get rid of inefficient joins
- Separates read and write operations with separating databases

* 2 action:
	- Commands: changing the state of data into application
	- Queries: handling complex join operations and returning a result and dont change the state of data into applications
- Large-scaled microservices architectures needs to manage high-volume data requirements
- Uses both CQRS and Event Sourcing pattens ti improve application performance

- Performing CRUD operations need to make complex validations and process long business logic, will cause to lock database operaions 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Event Sourcing Pattern

- Most applications saves data into databases with the current state of entity. (ghi đè lên trường hiện có khi có điều gì đó thay đổi) - mô hình truyền thống
- In large-scaled architectures, frequent update database operations can negatively impact database performance, responseiveness, and limits of scalability

- Instead of saving latest status of data into database, Event Sourcing pattern offers to save all event into database with sequential ordered of data events

- This events database called Event Store
- Instead of overiding the data into table, It create a new record of each change to data, and it becomes sequential list of past event
- Event Store database become the source-of-truth of data

- Sequectial event list using for generating Materialized View that represents final state of data to perform queries
- Event Store convert to read database with following the Materizlized Views Pattern
- Convert operation can be handle by publish/subcribe pattern with publish event with mesage broker sysems
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CQRS with Event Sourcing Pattern

- Store events into the write database; source-of-truth events database
- Read database of CQRS pattern provides materialized  views of the data with denormalized tables
- Materialized views read database consumes events from write database convert them in to denormalized views
- The writing database is never save status of data only event actions are stored
- Store history of data and able to reply any point of time in order to re-generate status of data

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Eventual Consistency Principle
- Strict Consistency: When we save data, the data should affect and seem immediately for every client
- Eventual Consistency: When we write any data, it will take some time for clients reading the data
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Logical and Physical Implementation of CQRS
- Logical Implementation of CQRS: Spliting Operations, Not databases. Separate the read(query) operations from the write (command) operations at the code level, but not
necessarily at the database level
	- Even though the same database is used, tha paths for reading and writing data are distinct
- Physical Inplementation of CQRS: Separate Databases. Splitting the read and write operations not just at the code level but also physically using separate database
	- Introduces data consistency and synchronization problem

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Add-migration InitialCreate -OutputDir Data/Migrations -Project Ordering.Infrastructure -StartupProject Ordering.API


















